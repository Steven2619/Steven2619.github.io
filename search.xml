<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript规范]]></title>
    <url>%2F2017%2F07%2F30%2FJavaScript%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[JavaScript规范内容列表 类型 对象 数组 字符串 函数 属性 变量 条件表达式和等号 块 注释 空白 逗号 分号 类型转换 命名约定 存取器 构造器 事件 模块 jQuery ES5 兼容性 类型 原始值: 相当于传值 string number boolean null undefined 123456var foo = 1, bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型: 相当于传引用 object array function 123456var foo = [1, 2], bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 [⬆] 对象 使用字面值创建对象 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用保留字 reserved words 作为键 12345678910111213// badvar superman = &#123; class: 'superhero', default: &#123; clark: 'kent' &#125;, private: true&#125;;// goodvar superman = &#123; klass: 'superhero', defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;; [⬆] 数组 使用字面值创建数组 12345// badvar items = new Array();// goodvar items = []; 如果你不知道数组的长度，使用push 12345678var someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 当你需要拷贝数组时使用slice. jsPerf 1234567891011var len = items.length, itemsCopy = [], i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 使用slice将类数组的对象转成数组. 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); //...dosomething&#125; [⬆] 字符串 对字符串使用单引号 &#39;&#39; 1234567891011// badvar name = "Bob Parr";// goodvar name = 'Bob Parr';// badvar fullName = "Bob " + this.lastName;// goodvar fullName = 'Bob ' + this.lastName; 超过80个字符的字符串应该使用字符串连接换行 注: 如果过度使用，长字符串连接可能会对性能有影响. jsPerf &amp; Discussion 12345678910111213141516171819// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that \was thrown because of Batman. \When you stop to think about \how Batman had anything to do \with this, you would get nowhere \fast.';// goodvar errorMessage = 'This is a super long error that ' + 'was thrown because of Batman.' + 'When you stop to think about ' + 'how Batman had anything to do ' + 'with this, you would get nowhere ' + 'fast.'; 编程时使用join而不是字符串连接来构建字符串，特别是IE: jsPerf. 1234567891011121314151617181920212223242526272829303132333435363738var items, messages, length, i;messages = [&#123; state: 'success', message: 'This one worked.'&#125;,&#123; state: 'success', message: 'This one worked as well.'&#125;,&#123; state: 'error', message: 'This one did not work.'&#125;];length = messages.length;// badfunction inbox(messages) &#123; items = '&lt;ul&gt;'; for (i = 0; i &lt; length; i++) &#123; items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return items + '&lt;/ul&gt;';&#125;// goodfunction inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; items[i] = messages[i].message; &#125; return '&lt;ul&gt;&lt;li&gt;' + items.join('&lt;/li&gt;&lt;li&gt;') + '&lt;/li&gt;&lt;/ul&gt;';&#125; [⬆] 函数 函数表达式: 1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 有名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用函数表达式(function() &#123; console.log('Welcome to the Internet. Please follow me.');&#125;)(); 绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同。 注: ECMA-262定义把块定义为一组语句，函数声明不是一个语句。阅读ECMA-262对这个问题的说明. 12345678910111213// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodif (currentUser) &#123; var test = function test() &#123; console.log('Yup.'); &#125;;&#125; 绝对不要把参数命名为 arguments, 这将会逾越函数作用域内传过来的 arguments 对象. 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; [⬆] 属性 当使用变量访问属性时使用中括号. 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); [⬆] 变量 总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。 12345// badsuperPower = new SuperPower();// goodvar superPower = new SuperPower(); 使用一个 var 以及新行声明多个变量，缩进4个空格。 123456789// badvar items = getItems();var goSportsTeam = true;var dragonball = 'z';// goodvar items = getItems(), goSportsTeam = true, dragonball = 'z'; 最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。 1234567891011121314151617// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i, items = getItems(), dragonball, goSportsTeam = true, len;// goodvar items = getItems(), goSportsTeam = true, dragonball, length, i; 条件表达式和等号 适当使用 === 和 !== 以及 == 和 !=. 条件表达式的强制类型转换遵循以下规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0, -0, or NaN 被计算为 false , 否则为 true 字符串 如果是空字符串 &#39;&#39; 则被计算为 false, 否则为 true 1234if ([0]) &#123; // true // An array is an object, objects evaluate to true&#125; 使用快捷方式. 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 阅读 Truth Equality and JavaScript 了解更多 [⬆] 块 给所有多行的块使用大括号 1234567891011// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125; [⬆] 注释 使用 /** ... */ 进行多行注释，包括描述，指定类型以及参数值和返回值 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行. 12345678910111213141516171819202122232425// badvar active = true; // is current tab// good// is current tabvar active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125; 如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 FIXME 或 TODO 帮助其他人迅速理解 1234567function Calculator() &#123; // FIXME: shouldn't use a global here total = 0; return this;&#125; 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; [⬆] 空白 将tab设为4个空格 1234567891011121314// badfunction() &#123;∙∙var name;&#125;// badfunction() &#123;∙var name;&#125;// goodfunction() &#123;∙∙∙∙var name;&#125; 大括号前放一个空格 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;); 在做长方法链时使用缩进. 1234567891011121314151617181920212223242526// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .class('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); [⬆] 逗号 不要将逗号放前面 12345678910111213141516171819202122232425// badvar once , upon , aTime;// goodvar once, upon, aTime;// badvar hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// goodvar hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; 不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。 123456789101112131415161718192021// badvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn',&#125;;var heroes = [ 'Batman', 'Superman',];// goodvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn'&#125;;var heroes = [ 'Batman', 'Superman']; [⬆] 分号 语句结束一定要加分号 1234567891011121314151617// bad(function() &#123; var name = 'Skywalker' return name&#125;)()// good(function() &#123; var name = 'Skywalker'; return name;&#125;)();// good;(function() &#123; var name = 'Skywalker'; return name;&#125;)(); [⬆] 类型转换 在语句的开始执行类型转换. 字符串: 12345678910111213// =&gt; this.reviewScore = 9;// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score';// goodvar totalScore = this.reviewScore + ' total score'; 对数字使用 parseInt 并且总是带上类型转换的基数. 123456789101112131415161718192021222324252627var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10);// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */var val = inputValue &gt;&gt; 0; 布尔值: 12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; [⬆] 命名约定 避免单个字符名，让你的变量名有描述意义。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 当命名对象、函数和实例时使用驼峰命名规则 123456789101112131415// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var this-is-my-object = &#123;&#125;;function c() &#123;&#125;;var u = new user(&#123; name: 'Bob Parr'&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;;var user = new User(&#123; name: 'Bob Parr'&#125;); 当命名构造函数或类时使用驼峰式大写 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 命名私有属性时前面加个下划线 _ 123456// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';// goodthis._firstName = 'Panda'; 当保存对 this 的引用时使用 _this. 1234567891011121314151617181920212223// badfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction() &#123; var that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction() &#123; var _this = this; return function() &#123; console.log(_this); &#125;;&#125; [⬆] 存取器 属性的存取器函数不是必需的 如果你确实有存取器函数的话使用getVal() 和 setVal(‘hello’) 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 如果属性是布尔值，使用isVal() 或 hasVal() 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 可以创建get()和set()函数，但是要保持一致 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber);&#125;Jedi.prototype.set = function(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function(key) &#123; return this[key];&#125;; [⬆] 构造器 给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。 1234567891011121314151617181920212223function Jedi() &#123; console.log('new jedi');&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log('fighting'); &#125;, block: function block() &#123; console.log('blocking'); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log('fighting');&#125;;Jedi.prototype.block = function block() &#123; console.log('blocking');&#125;; 方法可以返回 this 帮助方法可链。 1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20) // =&gt; undefined// goodJedi.prototype.jump = function() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。 123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || 'no name';&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return 'Jedi - ' + this.getName();&#125;; [⬆] 事件 当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function(e, listingId) &#123; // do something with listingId&#125;); 更好: 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function(e, data) &#123; // do something with data.listingId&#125;); [⬆] 模块 模块应该以 ! 开始，这保证了如果一个有问题的模块忘记包含最后的分号在合并后不会出现错误 这个文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致 加入一个名为noConflict()的方法来设置导出的模块为之前的版本并返回它 总是在模块顶部声明 &#39;use strict&#39;; 123456789101112131415161718// fancyInput/fancyInput.js!function(global) &#123; 'use strict'; var previousFancyInput = global.FancyInput; function FancyInput(options) &#123; this.options = options || &#123;&#125;; &#125; FancyInput.noConflict = function noConflict() &#123; global.FancyInput = previousFancyInput; return FancyInput; &#125;; global.FancyInput = FancyInput;&#125;(this); [⬆] jQuery 缓存jQuery查询 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 对DOM查询使用级联的 $(&#39;.sidebar ul&#39;) 或 $(&#39;.sidebar ul&#39;)，jsPerf 对有作用域的jQuery对象查询使用 find 1234567891011121314151617// bad$('.sidebar', 'ul').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good (slower)$sidebar.find('ul');// good (faster)$($sidebar[0]).find('ul'); [⬆] ECMAScript 5兼容性 参考Kangax的 ES5 compatibility table [⬆]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript+CSS 常用代码汇总]]></title>
    <url>%2F2017%2F07%2F30%2FJavaScript-CSS-%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[JavaScript+CSS 常用代码汇总 JavaScript和CSS3的常用代码总结。在平时工作和学习中，我们会遇到经常使用的片段，如果每次都去网上搜索的话，会浪费很多的时间，因此在这里把常用的代码汇总一下！ 目录 CSS初始化样式reset.css 去除浮动clearfix js操作cookie css强制换行/自动换行/强制不换行 table边界的样式 div上下左右居中 图片上下左右居中 js字符串翻转 iPad页面适配框架 google html5.js js产生随机数字 table中的td对齐属性 radio-checkbox-select requestAnimationFrame的兼容性处理 获取鼠标移动的方向 扩展String中的format html字段转换函数 js产生随机字符串 检测浏览器是否支持fixed 解析url中的参数 图片懒加载 jQuery回到顶部 图片hover放大 时间格式化 CSS初始化样式reset.css不同的浏览器对各个标签默认的样式是不一样的，而且有时候我们也不想使用浏览器给出的默认样式，我们就可以用reset.css去掉其默认样式 12345678910111213141516body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5 tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; 去除浮动clearfix通常我们在有浮动元素的情况下，会在同级目录下再创建一个&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;；不过这样会增加很多无用的代码。此时我们用:after这个伪元素来解决浮动的问题，如果当前层级有浮动元素，那么在其父级添加上clearfix类即可。123456789101112.clearfix:after &#123; content: "\00A0"; display: block; visibility: hidden; width: 0; height: 0; clear: both; font-size: 0; line-height: 0; overflow: hidden;&#125;.clearfix&#123;zoom:1&#125; js操作cookie12345678910111213141516171819202122232425262728293031323334353637var cookie = &#123; //写cookies setCookie: function (name, value)&#123; var Days = 365; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000); document.cookie = name + "=" + escape (value) + ";expires=" + exp.toGMTString(); &#125;, //读取cookies getCookie: function (name)&#123; var arr,reg= new RegExp( "(^| )" +name+ "=([^;]*)(;|$)" ); if (arr=document.cookie.match(reg)) return unescape(arr[2]); else return null ; &#125;, //删除cookies， name可以为字符串('username')或数组(['username', 'password', ...]) delCookie: function (name) &#123; var delItem = function(item)&#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = cookie.getCookie(item); if (cval!== null ) document.cookie= item + "=" +cval+ ";expires=" +exp.toGMTString(); &#125; if( typeof name === 'string' )&#123; delItem( name ); &#125;else&#123; for(var i=0, len=name.length; i&lt;len; i++)&#123; delItem( name[i] ); &#125; &#125; &#125;&#125; css强制换行/自动换行/强制不换行123456789101112131415/* 强制不换行 */div&#123; white-space:nowrap;&#125;/* 自动换行 */div&#123; word-wrap: break-word; word-break: normal;&#125;/* 强制英文单词断行 */div&#123; word-break:break-all;&#125; ####table边界的样式12table &#123; border: 1px solid #000; padding: 0; border-collapse: collapse; table-layout: fixed; margin-top: 10px;&#125;table td &#123; height: 30px; border: 1px solid #000; background: #fff; font-size: 15px; padding: 3px 3px 3px 8px; color: #000; width: 160px;&#125; div上下左右居中123456789div&#123; position:absolute; width:400px; height:300px; left:50%; top:50%; margin-left:-200px; margin-top:-150px;&#125; 图片上下左右居中一种常用的方式是把外层的div设置为table-cell；然后让内部的元素上下左右居中。当然也还有一种方式，就是把img当做div，参考6中的代码进行设置。CSS代码如下：12345678.content&#123; width: 400px; height: 400px; border: 1px solid #ccc; text-align: center; display:table-cell; vertical-align:middle;&#125; html代码如下：123&lt;div class="content"&gt; &lt;img src="./4.jpg" alt="img"&gt;&lt;/div&gt; js字符串翻转js中没有直接对字符串进行反转的，需要我们先转换成数组，然后使用数组中的reverse()方法翻转，最后在把数组拼接回字符串。123var str = "abcdefg";var revs = str.split("").reverse().join("");console.log(revs); iPad页面适配框架这是一个适配iPad页面的大致框架，包括竖屏和横屏123456789101112131415161718iPad 适配/* ipad 竖屏 */@media only screenand (min-device-width : 768px)and (max-device-width : 1024px)and (orientation : portrait) &#123; body&#123; color:#000; &#125; /* … */&#125;/* ipad 横屏 */@media only screenand (min-device-width : 768px)and (max-device-width : 1024px)and (orientation : landscape) &#123; body&#123; color:#000; &#125; /* … */&#125; google html5.js这是Google提供的js框架，使IE8及以下的浏览器支持html5新标签html5.js 链接12345678/* HTML5 Shiv v3.7.0 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed*/(function(l,f)&#123;function m()&#123;var a=e.elements;return"string"==typeof a?a.split(" "):a&#125;function i(a)&#123;var b=n[a[o]];b||(b=&#123;&#125;,h++,a[o]=h,n[h]=b);return b&#125;function p(a,b,c)&#123;b||(b=f);if(g)return b.createElement(a);c||(c=i(b));b=c.cache[a]?c.cache[a].cloneNode():r.test(a)?(c.cache[a]=c.createElem(a)).cloneNode():c.createElem(a);return b.canHaveChildren&amp;&amp;!s.test(a)?c.frag.appendChild(b):b&#125;function t(a,b)&#123;if(!b.cache)b.cache=&#123;&#125;,b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag();a.createElement=function(c)&#123;return!e.shivMethods?b.createElem(c):p(c,a,b)&#125;;a.createDocumentFragment=Function("h,f","return function()&#123;var n=f.cloneNode(),c=n.createElement;h.shivMethods&amp;&amp;("+m().join().replace(/[\w\-]+/g,function(a)&#123;b.createElem(a);b.frag.createElement(a);return'c("'+a+'")'&#125;)+");return n&#125;")(e,b.frag)&#125;function q(a)&#123;a||(a=f);var b=i(a);if(e.shivCSS&amp;&amp;!j&amp;&amp;!b.hasCSS)&#123;var c,d=a;c=d.createElement("p");d=d.getElementsByTagName("head")[0]||d.documentElement;c.innerHTML="x&lt;style&gt;article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section&#123;display:block&#125;mark&#123;background:#FF0;color:#000&#125;template&#123;display:none&#125;&lt;/style&gt;";c=d.insertBefore(c.lastChild,d.firstChild);b.hasCSS=!!c&#125;g||t(a,b);return a&#125;var k=l.html5||&#123;&#125;,s=/^&lt;|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,r=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,j,o="_html5shiv",h=0,n=&#123;&#125;,g;(function()&#123;try&#123;var a=f.createElement("a");a.innerHTML="&lt;xyz&gt;&lt;/xyz&gt;";j="hidden"in a;var b;if(!(b=1==a.childNodes.length))&#123;f.createElement("a");var c=f.createDocumentFragment();b="undefined"==typeof c.cloneNode||"undefined"==typeof c.createDocumentFragment||"undefined"==typeof c.createElement&#125;g=b&#125;catch(d)&#123;g=j=!0&#125;&#125;)();var e=&#123;elements:k.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:"3.7.0",shivCSS:!1!==k.shivCSS,supportsUnknownElements:g,shivMethods:!1!==k.shivMethods,type:"default",shivDocument:q,createElement:p,createDocumentFragment:function(a,b)&#123;a||(a=f);if(g)return a.createDocumentFragment();for(var b=b||i(a),c=b.frag.cloneNode(),d=0,e=m(),h=e.length;d&lt;h;d++)c.createElement(e[d]);return c&#125;&#125;;l.html5=e;q(f)&#125;)(this,document); js产生随机数字这是利用js里的Math.random()产生的。若使用 *1000000 然后再强制转成整型也行；不过使用下面的方式可以更加简洁一些，直接截取随机数的最后6位进行返回：123function getRanNum()&#123; return (''+Math.random()).slice(-6); // Math.random().toString().slice(-6)&#125; 其实，产生32位的字母和数字混合的字符串也比较简单，先给出一个含有包含所有字符和数字的混合字符串，然后使用Math.random()摘取每位上的字符进行拼接，最后能够得到一个32位的随机字符串；或者使用js的md5()进行加密也可以。可以参考本人收藏的md5加密代码【md5加密】 table中td的对齐属性在table中有两个默认的属性：align(横向对齐属性)和valign(竖向对齐属性)。align有三个值：left(左对齐，默认)，center(左右居中)，right(右对齐)；如想要文字居中，可以：1&lt;td align='center'&gt;wenzi&lt;/td&gt; valign也三个值：top(上对齐)，middle(上下居中，默认)，bottom(下对齐)；如想要文字上居中，可以：1&lt;td valign='top'&gt;wenzi&lt;/td&gt; 当然，为了实现结构与样式的分离，推荐使用CSS的属性。1234td&#123; align: center; /* 横向对齐：left, center, right */ vertical-align: top; /* 竖向对齐：top, middle, bottom */&#125; radio-checkbox-selectjquery对radio, checkbox的input标签和select标签的操作 input[type=radio]的操作1234567891011// boolean, 判断radio是否有被选中的元素$('#myradio input[type=radio]').is(':checked');// 设置radio选中某个元素$('#myradio input:eq(1)').prop('checked', true);// 设置radio取消选中某个元素$('#myradio input:eq(1)').prop('checked', false);// 获取选中的radio的值var val = $('#myradio input[type=radio]:checked').val(); input[type=checkbox]的操作1234567891011121314151617181920212223242526272829303132// 判断复选框是否选中var bool = $('#mycheckbox input[type=checkbox]').is(':checked') ;// 全选，所有的checkbox都添加上checked属性$('#checkall').click(function()&#123; $('#like input[type=checkbox]').prop('checked', true);&#125;)// 反选，判断当前的checkbox是否被选中，若被选中则设置checked属性为false，否则设置checked属性为true$('#reverse').click(function()&#123; $('#like input[type=checkbox]').each(function()&#123; if($(this).is(':checked'))&#123; $(this).prop('checked', false); &#125;else&#123; $(this).prop('checked', true); &#125; &#125;)&#125;)// 取消选中，去掉所有checkbox的checked属性$('#deleteall').click(function()&#123; $('#like input[type=checkbox]').prop('checked', false);&#125;)// 获取选中的值$('#getcheckval').click(function()&#123; var result = []; $('#mycheckbox input[type=checkbox]:checked').each(function()&#123; result.push( $(this).val() ); &#125;) console.log(result);&#125;) select标签12// 获取select选中的value值，给select一个id，直接使用`val()`获取就行$('#province').val() requestAnimationFrame的兼容性处理123456789101112131415161718192021222324// http://paulirish.com/2011/requestanimationframe-for-smart-animating/// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel// MIT license(function() &#123; var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;;&#125;()); 获取鼠标移动的方向我们一定遇见过鼠标从哪个地方进入到某div中，遮罩就从哪个方向出现，鼠标从哪个地方离开这个div，遮罩就从哪个方向消失。整个动画实现的基础就是获取鼠标移动的方向。 123456789101112131415161718192021/* * 获取元素移动的方向 * @param $element 元素的jQuery对象 * @param event 事件对象 * @return direction 返回一个数字：0:上，1:右，2:下，3:左 **/function getDirection($element, event) &#123; var w = $element.width(), h = $element.height(), x = (event.pageX - $element.offset().left - (w / 2)) * (w &gt; h ? (h / w) : 1), y = (event.pageY - $element.offset().top - (h / 2)) * (h &gt; w ? (w / h) : 1), direction = Math.round((((Math.atan2(y, x) * (180 / Math.PI)) + 180) / 90) + 3) % 4; return direction;&#125;$('#content').on('mouseenter', function(event)&#123; console.log( 'enter: '+ getDirection($(this), event) );&#125;).on('mouseleave', function(event)&#123; console.log( 'leave: '+getDirection($(this), event) );&#125;) 扩展String中的format 对String原型进行扩展: String.prototype.methodName=function… 正则表达式： /{(\d+)}/g ；取”{0}”这种格式的占位符，并对里面的数字放入子组 js 的 replace 方法有一种重载, string.format(regex , function(group0【匹配项】,group1【子组第一个】…){ //code… }) ；对于每次匹配到的一个占位符，都从参数相应的位置取得替换项。 12345678910String.prototype.format = function () &#123; var args = arguments; var reg = /\&#123;(\d+)\&#125;/g; return this.replace(reg, function (g0, g1) &#123; return args[+g1] || ''; &#125;);&#125;;//用法："hello &#123;0&#125;,your age is &#123;1&#125;,so &#123;0&#125;'s age is &#123;1&#125;".format("tom",12);//"hello tom,your age is 12,so tom's age is 12" 若不想在String的类型上进行拓展，也可以这样修改： 1234567891011121314var tool = &#123; format : function(str)&#123; var args = arguments; var reg = /\&#123;(\d+)\&#125;/g; return str.replace(reg, function (g0, g1) &#123; g1++; return args[+g1] || ''; &#125;); &#125;&#125;tool.format("hello &#123;0&#125;,your age is &#123;1&#125;,so &#123;0&#125;'s age is &#123;1&#125;", "tom", 12);// "hello tom,your age is 12,so tom's age is 12" html字段转换函数123456function escapeHTML(text) &#123; var replacements= &#123;"&lt;": "&amp;lt;", "&gt;": "&amp;gt;","&amp;": "&amp;amp;", "\"": "&amp;quot;"&#125;; return text.replace(/[&lt;&gt;&amp;"]/g, function(character) &#123; return replacements[character]; &#125;);&#125; js产生随机字符串1Math.random().toString(36).substr(2); 很有意思，研究了一下，基本上toString后的参数规定可以是2-36之间的任意整数，不写的话默认是10（也就是十进制），此时返回的值就是那个随机数。 若是偶数，返回的数值字符串都是短的，若是奇数，则返回的将是一个很大长度的表示值。若10 才会包含字母。所以如果想得到一长串的随机字符，则需使用一个 &gt; 10 且是奇数的参数，另外根据长度自行使用slice(2,n)截取！ 检测浏览器是否支持fixed1234567891011121314151617function isSupportFixed() &#123; var userAgent = window.navigator.userAgent, ios = userAgent.match(/(iPad|iPhone|iPod)\s+OS\s([\d_\.]+)/), ios5below = ios &amp;&amp; ios[2] &amp;&amp; (parseInt(ios[2].replace(/_/g, '.'), 10) &lt; 5), operaMini = /Opera Mini/i.test(userAgent), body = document.body, div, isFixed; div = document.createElement('div'); div.style.cssText = 'display:none;position:fixed;z-index:100;'; body.appendChild(div); isFixed = window.getComputedStyle(div).position != 'fixed'; body.removeChild(div); div = null; return !!(isFixed || ios5below || operaMini);&#125; 解析url中的参数用于解析当前URL中带的参数，如 http://www.xiabingbao.com/javascript/2015/01/30/geturl-param/?a=1&amp;b=wenzi 123456function parseUrl(search, name)&#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = url.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;parseUrl(window.location.search, 'id'); 图片懒加载对需要懒加载的图片，把真实的图片地址放到_src的属性中，不要写src属性，因为src的值为空时也会请求，或者为src设置一个1x1的占位图片。 把整个页面里的图片划分区域，每个区域按顺序设置图片的name属性，值为page_cnt_{num}，num从1开始依次递增不能有间断： 12345678910&lt;div class="area1"&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_1" /&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_1" /&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_1" /&gt;&lt;/div&gt;&lt;div class="area2"&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_2" /&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_2" /&gt; &lt;img _src="http://inews.gtimg.com/newsapp_ls/0/301518240_150120/0" name="page_cnt_2" /&gt;&lt;/div&gt; 当滚动条滚动到当前区域时，则把area1区域里name的值是page_cnt_1的图片都加载完成，而area2则在滚动条再次滚动到相应的距离时才加载。 12345(function()&#123;var a=this;a.pageSize=1E3;a.pageQuotiety=.5;a.imgName="page_cnt_";a.imgs=[];var e,g;e=window.navigator.userAgent.toLowerCase();g=/msie/.test(e);/gecko/.test(e);/opera/.test(e);/safari/.test(e);var f=function(b,a)&#123;var d=a?a:document;return"object"==typeof b?b:d.getElementsByName(b)&#125;;a.getWindowSize=function()&#123;var b=&#123;&#125;;if(window.self&amp;&amp;self.innerWidth)return b.width=self.innerWidth,b.height=self.innerHeight,b;if(document.documentElement&amp;&amp;document.documentElement.clientHeight)return b.width=document.documentElement.clientWidth,b.height=document.documentElement.clientHeight,b;b.width=document.body.clientWidth;b.height=document.body.clientHeight;return b&#125;;a.getObjPosition=function(b)&#123;var a=&#123;&#125;;a.x=b.offsetLeft;for(a.y=b.offsetTop;b=b.offsetParent;)a.x+=b.offsetLeft,a.y+=b.offsetTop;return a&#125;;a._getPageScroll=function()&#123;var a;"undefined"!=typeof window.pageYOffset?a=window.pageYOffset:document.documentElement&amp;&amp;document.documentElement.scrollTop?a=document.documentElement.scrollTop:document.body&amp;&amp;(a=document.body.scrollTop);return a&#125;;a._loadImages=function(a)&#123;if(a)&#123;var c=a;"string"==typeof a&amp;&amp;(c=f(a));for(a=0;a&lt;c.length;a++)&#123;var d=c[a];"object"==typeof d&amp;&amp;d.getAttribute("_src")&amp;&amp;(d.setAttribute("src",d.getAttribute("_src")),d.removeAttribute("_src",0))&#125;delete c&#125;&#125;;a._loadAllImgs=function()&#123;for(var b=0;a.imgs[b];)a._loadImages(a.imgs[b][0]),b++&#125;;a.getImgPosition=function()&#123;for(var b=1,c=f(a.imgName+b);c&amp;&amp;0&lt;c.length;)&#123;var c=f("page_cnt_"+b),d=a.getImgLoadPosition(c[0]);a.imgs.push([c,c[0],d]);b++;c=f(a.imgName+b)&#125;&#125;;a.getImgLoadPosition=function(b)&#123;var c=&#123;imgTop:0,pageTop:0&#125;;b&amp;&amp;(a.getWindowSize(),c.imgTop=parseInt(a.getObjPosition(b).y),c.pageTop=parseInt(1E3*(c.imgTop/1E3-a.pageQuotiety)));return c&#125;;a._addScrollEven=function()&#123;g?window.attachEvent("onscroll",a._scrollFn):window.addEventListener("scroll",a._scrollFn,!1)&#125;;a._removeScrollEven=function()&#123;g?window.detachEvent("onscroll",a._scrollFn):window.removeEventListener("scroll",a._scrollFn,!1)&#125;;a._scrollFn=function()&#123;var b=a._getPageScroll(),c=a.getWindowSize().height;if(0==c)a._loadAllImgs();else for(var d=0,e=0;a.imgs[d];)b+c&lt;a.imgs[d][2].pageTop||(a._loadImages(a.imgs[d][0]),e++),d++,e&gt;=a.imgs.length&amp;&amp;a._removeScrollEven()&#125;;a.getImgPosition();a._addScrollEven();a._scrollFn()&#125;)(); jQuery回到顶部回到顶部有不少的方法，没有缓冲效果的话，先在顶部放置一个a标签，然后给回到顶部的链接一个#:12345// 顶部标签&lt;a id="top"&gt;&lt;/a&gt;// 回到顶部的按钮&lt;a href="#top"&gt;回到顶部&lt;/a&gt; 如果需要缓冲效果的话，可以使用jQuery中的animate:1$('body,html').animate(&#123;scrollTop:0&#125;, 500); 图片hover放大12345678910111213141516171819a&#123; position: relative; overflow: hidden; display: block;&#125;img&#123; -webkit-transition: transform .2s ease-out; -moz-transition: transform .2s ease-out; -ms-transition: transform .2s ease-out; -o-transition: transform .2s ease-out; transition: transform .2s ease-out;&#125;a:hover img&#123; -webkit-transform: scale(1.1); -moz-transform: scale(1.1); -ms-transform: scale(1.1); -o-transform: scale(1.1); transform: scale(1.1);&#125; 123&lt;a href=""&gt; &lt;img src="" /&gt;&lt;/a&gt; 时间格式化1234567891011121314151617181920212223242526272829//格式化日期Date.prototype.Format = function (fmt) &#123; var o = &#123; "y+": this.getFullYear(), "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S+": this.getMilliseconds() //毫秒 &#125;; for (var k in o) &#123; if (new RegExp("(" + k + ")").test(fmt))&#123; if(k == "y+")&#123; fmt = fmt.replace(RegExp.$1, ("" + o[k]).substr(4 - RegExp.$1.length)); &#125; else if(k=="S+")&#123; var lens = RegExp.$1.length; lens = lens==1?3:lens; fmt = fmt.replace(RegExp.$1, ("00" + o[k]).substr(("" + o[k]).length - 1,lens)); &#125; else&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; &#125; return fmt;&#125; 使用：12345var date = new Date();console.log(date.Format("yyyy年MM月dd日 hh:mm:ss.S")); //输出: 2016年04月01日 10:41:08.133console.log(date.Format("yyyy-MM-dd hh:mm:ss")); //输出: 2016-04-01 10:41:08console.log(date.Format("yy-MM-dd hh:mm:ss")); //输出: 16-04-01 10:41:08console.log(date.Format("yy-M-d hh:mm:ss")); //输出: 16-4-1 10:41:08]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
